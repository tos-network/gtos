#ifndef HEADER_at_src_crypto_ed25519_avx2_at_curve25519_h
#define HEADER_at_src_crypto_ed25519_avx2_at_curve25519_h

/* AVX2 Ed25519 point operations.

   This provides Ed25519 point arithmetic using extended twisted Edwards
   coordinates (X:Y:T:Z) where x=X/Z, y=Y/Z, xy=T/Z.

   The implementation uses AVX2 field arithmetic for acceleration. */

#if AT_HAS_AVX && !AT_HAS_AVX512_IFMA

#include "at_f25519.h"

/* CURVE25519_PRECOMP_XY turns on/off the precomputation of (Y-X), (Y+X)
   for tables, which saves 2 field adds per point add. */
#define CURVE25519_PRECOMP_XY 1

AT_PROTOTYPES_BEGIN

/* ========================================================================
   Point Type
   ======================================================================== */

/* at_curve25519_edwards_t represents a point on the Ed25519 curve
   in extended twisted Edwards coordinates (X:Y:T:Z).
   The affine coordinates are x=X/Z, y=Y/Z, and xy=T/Z. */
struct at_curve25519_edwards {
  at_f25519_t X[1];
  at_f25519_t Y[1];
  at_f25519_t T[1];
  at_f25519_t Z[1];
};
typedef struct at_curve25519_edwards at_curve25519_edwards_t;

/* at_ed25519_point_t is an alias for the Edwards curve point type. */
typedef at_curve25519_edwards_t at_ed25519_point_t;

/* ========================================================================
   Curve Constants (Precomputed)
   ======================================================================== */

/* Include precomputed tables in radix-2^25.5 format.
   These are generated by gen_avx2_tables.c and stored in table/. */
#include "../table/at_curve25519_table_avx2.c"

/* Runtime-mutable storage (initialized from precomputed) */
static at_ed25519_point_t at_ed25519_base_point_storage[1];
static at_f25519_t at_ed25519_order8_point_y0_storage[1];
static at_f25519_t at_ed25519_order8_point_y1_storage[1];
static int at_ed25519_avx2_constants_initialized = 0;

#define at_ed25519_base_point at_ed25519_base_point_storage
#define at_ed25519_order8_point_y0 at_ed25519_order8_point_y0_storage
#define at_ed25519_order8_point_y1 at_ed25519_order8_point_y1_storage

/* Initialize curve constants from precomputed tables */
void at_ed25519_avx2_init_constants( void );

/* ========================================================================
   Basic Point Operations
   ======================================================================== */

/* at_ed25519_point_set_zero sets r = 0 (point at infinity).
   The neutral element is (0:1:0:1) in extended coordinates. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_set_zero( at_ed25519_point_t * r ) {
  at_f25519_set( r->X, at_f25519_zero );
  at_f25519_set( r->Y, at_f25519_one );
  at_f25519_set( r->T, at_f25519_zero );
  at_f25519_set( r->Z, at_f25519_one );
  return r;
}

/* at_ed25519_point_set_zero_precomputed sets r = 0 (point at infinity)
   for precomputed format. In precomputed format, T is replaced by k*T. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_set_zero_precomputed( at_ed25519_point_t * r ) {
  at_f25519_set( r->X, at_f25519_zero );
  at_f25519_set( r->Y, at_f25519_one );
  at_f25519_set( r->T, at_f25519_zero );
  at_f25519_set( r->Z, at_f25519_one );
  return r;
}

/* at_ed25519_point_is_identity returns 1 if a == identity, 0 otherwise. */
AT_25519_INLINE int
at_ed25519_point_is_identity( at_ed25519_point_t const * a ) {
  /* Identity is (0:c:0:c) for any nonzero c, so X=0 and Y=Z */
  return at_f25519_is_zero( a->X ) & at_f25519_eq( a->Y, a->Z );
}

/* at_ed25519_point_is_zero is an alias for is_identity. */
AT_25519_INLINE int
at_ed25519_point_is_zero( at_ed25519_point_t const * a ) {
  return at_ed25519_point_is_identity( a );
}

/* at_ed25519_point_set copies r = a, and returns r. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_set( at_ed25519_point_t *       r,
                      at_ed25519_point_t const * a ) {
  at_f25519_set( r->X, a->X );
  at_f25519_set( r->Y, a->Y );
  at_f25519_set( r->T, a->T );
  at_f25519_set( r->Z, a->Z );
  return r;
}

/* at_ed25519_point_from sets r = (x : y : z : t). */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_from( at_ed25519_point_t * r,
                       at_f25519_t const *  x,
                       at_f25519_t const *  y,
                       at_f25519_t const *  z,
                       at_f25519_t const *  t ) {
  at_f25519_set( r->X, x );
  at_f25519_set( r->Y, y );
  at_f25519_set( r->Z, z );
  at_f25519_set( r->T, t );
  return r;
}

/* at_ed25519_point_to extracts (x, y, z, t) from a point. */
AT_25519_INLINE void
at_ed25519_point_to( at_f25519_t *              x,
                     at_f25519_t *              y,
                     at_f25519_t *              z,
                     at_f25519_t *              t,
                     at_ed25519_point_t const * a ) {
  at_f25519_set( x, a->X );
  at_f25519_set( y, a->Y );
  at_f25519_set( z, a->Z );
  at_f25519_set( t, a->T );
}

/* at_ed25519_point_neg computes r = -a. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_neg( at_ed25519_point_t *       r,
                      at_ed25519_point_t const * a ) {
  at_f25519_neg( r->X, a->X );
  at_f25519_set( r->Y, a->Y );
  at_f25519_set( r->Z, a->Z );
  at_f25519_neg( r->T, a->T );

  /* Reduce after negation. at_f25519_neg uses bias constants that assume
     reduced input. If input limbs are near the bias values, the output
     can have limbs exceeding the expected bit widths, causing overflow
     in subsequent SIMD operations. */
  at_f25519_carry( r->X );
  at_f25519_carry( r->T );
  return r;
}

/* ========================================================================
   Point Doubling (Partial and Final)
   ======================================================================== */

/* at_ed25519_partial_dbl computes intermediate values for point doubling
   using dbl-2008-hwcd formula for twisted Edwards curve with a=-1 (Ed25519).
   Formula: A=X^2, B=Y^2, C=2*Z^2, D=-A (since a=-1)
            E=(X+Y)^2-A-B=2XY, G=D+B=B-A, F=G-C, H=D-B=-(A+B)
   Output: X3=E*F, Y3=G*H, T3=E*H, Z3=G*F
   This allows chaining multiple doublings efficiently.
   Output is in "lazy" form that needs at_ed25519_point_add_final_mul. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_partial_dbl( at_ed25519_point_t *       r,
                        at_ed25519_point_t const * a ) {
  at_f25519_t a_sq[1], b_sq[1], two_c[1], sum[1];

  /* A = X^2, B = Y^2 */
  at_f25519_sqr2( a_sq, a->X, b_sq, a->Y );

  /* E = (X+Y)^2 - A - B = 2XY (stored in r->T) */
  at_f25519_add_nr( r->T, a->X, a->Y );
  at_f25519_sqr( r->T, r->T );
  at_f25519_add_nr( sum, a_sq, b_sq );  /* A + B */
  at_f25519_sub_nr( r->T, r->T, sum );  /* E = (X+Y)^2 - (A+B) */

  /* G = B - A (stored in r->Z) for Ed25519 where a=-1 */
  at_f25519_sub_nr( r->Z, b_sq, a_sq );

  /* F = G - 2*Z^2 (stored in r->X) */
  at_f25519_sqr( two_c, a->Z );
  at_f25519_add_nr( two_c, two_c, two_c );
  at_f25519_sub_nr( r->X, r->Z, two_c );

  /* H = -(A+B) (stored in r->Y)
     IMPORTANT: sum is unreduced from add_nr, so we must reduce it first.
     Otherwise, limbs can exceed the neg bias constants, causing underflow. */
  at_f25519_carry( sum );
  at_f25519_neg( r->Y, sum );

  return r;
}

/* at_ed25519_point_add_final_mul computes the final multiplications for point add.
   Input is partial result from partial_dbl or partial_add.
   r = (E*F : G*H : F*G : E*H) */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_add_final_mul( at_ed25519_point_t * restrict r,
                                at_ed25519_point_t const * restrict partial ) {
  at_f25519_t E[1], F[1], G[1], H[1];

  /* Reduce partial results before mul4.
     The partial values come from _nr operations and can have limbs up to ~28 bits.
     When mul4 computes 19*b[j], the result can exceed 32 bits, causing silent
     truncation in the SIMD wv_mul_ll (32x32->64) operation. Carry propagation
     ensures limbs are in the proper 25/26-bit ranges. */
  at_f25519_set( E, partial->T );
  at_f25519_set( F, partial->X );
  at_f25519_set( G, partial->Z );
  at_f25519_set( H, partial->Y );
  at_f25519_carry( E );
  at_f25519_carry( F );
  at_f25519_carry( G );
  at_f25519_carry( H );

  at_f25519_mul4( r->X, E, F,
                  r->Y, G, H,
                  r->Z, F, G,
                  r->T, E, H );

  /* Canonicalize to ensure field elements are in [0, p) */
  at_f25519_canonicalize( r->X );
  at_f25519_canonicalize( r->Y );
  at_f25519_canonicalize( r->Z );
  at_f25519_canonicalize( r->T );
  return r;
}

/* at_ed25519_point_add_final_mul_projective is similar but outputs projective form.
   Used for intermediate doublings. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_add_final_mul_projective( at_ed25519_point_t * restrict r,
                                           at_ed25519_point_t const * restrict partial ) {
  return at_ed25519_point_add_final_mul( r, partial );
}

/* at_ed25519_point_dbln computes r = 2^n * a, and returns r. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_dbln( at_ed25519_point_t *       r,
                       at_ed25519_point_t const * a,
                       int const                  n ) {
  at_ed25519_point_t t[1];
  at_ed25519_partial_dbl( t, a );
  for( int i = 1; i < n; i++ ) {
    at_ed25519_point_add_final_mul_projective( r, t );
    at_ed25519_partial_dbl( t, r );
  }
  return at_ed25519_point_add_final_mul( r, t );
}

AT_PROTOTYPES_END

#endif /* AT_HAS_AVX2 && !AT_HAS_AVX512 */

#endif /* HEADER_at_src_crypto_ed25519_avx2_at_curve25519_h */
