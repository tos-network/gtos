#ifndef HEADER_at_src_crypto_ed25519_avx512_general_at_curve25519_h
#define HEADER_at_src_crypto_ed25519_avx512_general_at_curve25519_h

/* AVX-512F (non-IFMA) Ed25519 point operations.

   This provides Ed25519 point arithmetic using extended twisted Edwards
   coordinates (X:Y:T:Z) where x=X/Z, y=Y/Z, xy=T/Z.

   The implementation uses AVX-512F field arithmetic for acceleration.
   Uses the same 10-limb radix-2^25.5 format as AVX2, enabling table sharing. */

#if AT_HAS_AVX512_GENERAL

#include "at_crypto_base.h"
#include "at_f25519.h"
#include "at_curve25519_scalar.h"

/* CURVE25519_PRECOMP_XY turns on/off the precomputation of (Y-X), (Y+X)
   for tables, which saves 2 field adds per point add. */
#define CURVE25519_PRECOMP_XY 1

AT_PROTOTYPES_BEGIN

/* ========================================================================
   Point Type
   ======================================================================== */

/* at_curve25519_edwards_t represents a point on the Ed25519 curve
   in extended twisted Edwards coordinates (X:Y:T:Z).
   The affine coordinates are x=X/Z, y=Y/Z, and xy=T/Z. */
struct at_curve25519_edwards {
  at_f25519_t X[1];
  at_f25519_t Y[1];
  at_f25519_t T[1];
  at_f25519_t Z[1];
};
typedef struct at_curve25519_edwards at_curve25519_edwards_t;

/* at_ed25519_point_t is an alias for the Edwards curve point type. */
typedef at_curve25519_edwards_t at_ed25519_point_t;

/* ========================================================================
   Curve Constants (Precomputed)
   ======================================================================== */

/* Include precomputed tables in radix-2^25.5 format.
   AVX-512 General uses the same 10-limb format as AVX2, so we share the table.
   These are generated by gen_avx2_tables.c and stored in table/. */
#define AT_CURVE25519_TABLE_AVX2_STANDALONE 1
#include "../table/at_curve25519_table_avx2.c"

/* Runtime-mutable storage (initialized from precomputed).
   These are defined in at_r2526x8.c and must be extern to ensure
   a single shared instance across all translation units. */
extern at_ed25519_point_t at_ed25519_base_point_storage[1];
extern at_f25519_t at_ed25519_order8_point_y0_storage[1];
extern at_f25519_t at_ed25519_order8_point_y1_storage[1];
extern int at_ed25519_avx512_general_curve_constants_initialized;

#define at_ed25519_base_point at_ed25519_base_point_storage
#define at_ed25519_order8_point_y0 at_ed25519_order8_point_y0_storage
#define at_ed25519_order8_point_y1 at_ed25519_order8_point_y1_storage

/* Initialize curve constants from precomputed tables.
   Called automatically by curve operations if not already initialized. */
AT_25519_INLINE void
at_ed25519_avx512_general_init_curve_constants( void ) {
  if( at_ed25519_avx512_general_curve_constants_initialized ) return;

  /* Initialize field constants first (d, sqrtm1, k, etc.) */
  at_ed25519_avx512_general_init_constants();

  /* Override field constants with precomputed tables (radix-2^25.5 format).
     The frombytes version may have different values due to representation differences. */
  at_f25519_set( at_f25519_d_storage, at_f25519_d_precomputed );
  at_f25519_set( at_f25519_sqrtm1_storage, at_f25519_sqrtm1_precomputed );
  at_f25519_set( at_f25519_k_storage, at_f25519_k_precomputed );
  at_f25519_neg( at_f25519_minus_k_storage, at_f25519_k_storage );

  /* Copy precomputed base point */
  for( int i = 0; i < 12; i++ ) {
    at_ed25519_base_point_storage->X->el[i] = at_ed25519_base_point_precomputed->X->el[i];
    at_ed25519_base_point_storage->Y->el[i] = at_ed25519_base_point_precomputed->Y->el[i];
    at_ed25519_base_point_storage->T->el[i] = at_ed25519_base_point_precomputed->T->el[i];
    at_ed25519_base_point_storage->Z->el[i] = at_ed25519_base_point_precomputed->Z->el[i];
  }

  /* Copy low-order point Y coordinates */
  for( int i = 0; i < 12; i++ ) {
    at_ed25519_order8_point_y0_storage->el[i] = at_ed25519_order8_point_y0_precomputed->el[i];
    at_ed25519_order8_point_y1_storage->el[i] = at_ed25519_order8_point_y1_precomputed->el[i];
  }

  at_ed25519_avx512_general_curve_constants_initialized = 1;
}

/* ========================================================================
   Basic Point Operations
   ======================================================================== */

/* at_ed25519_point_set_zero sets r = 0 (point at infinity).
   The neutral element is (0:1:0:1) in extended coordinates. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_set_zero( at_ed25519_point_t * r ) {
  at_f25519_set( r->X, at_f25519_zero );
  at_f25519_set( r->Y, at_f25519_one );
  at_f25519_set( r->T, at_f25519_zero );
  at_f25519_set( r->Z, at_f25519_one );
  return r;
}

/* at_ed25519_point_set_zero_precomputed sets r = 0 (point at infinity)
   for precomputed format. In precomputed format, T is replaced by k*T. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_set_zero_precomputed( at_ed25519_point_t * r ) {
  at_f25519_set( r->X, at_f25519_zero );
  at_f25519_set( r->Y, at_f25519_one );
  at_f25519_set( r->T, at_f25519_zero );
  at_f25519_set( r->Z, at_f25519_one );
  return r;
}

/* at_ed25519_point_is_identity returns 1 if a == identity, 0 otherwise. */
AT_25519_INLINE int
at_ed25519_point_is_identity( at_ed25519_point_t const * a ) {
  /* Identity is (0:c:0:c) for any nonzero c, so X=0 and Y=Z */
  return at_f25519_is_zero( a->X ) & at_f25519_eq( a->Y, a->Z );
}

/* at_ed25519_point_is_zero is an alias for is_identity. */
AT_25519_INLINE int
at_ed25519_point_is_zero( at_ed25519_point_t const * a ) {
  return at_ed25519_point_is_identity( a );
}

/* at_ed25519_point_set copies r = a, and returns r. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_set( at_ed25519_point_t *       r,
                      at_ed25519_point_t const * a ) {
  at_f25519_set( r->X, a->X );
  at_f25519_set( r->Y, a->Y );
  at_f25519_set( r->T, a->T );
  at_f25519_set( r->Z, a->Z );
  return r;
}

/* at_ed25519_point_from sets r = (x : y : z : t). */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_from( at_ed25519_point_t * r,
                       at_f25519_t const *  x,
                       at_f25519_t const *  y,
                       at_f25519_t const *  z,
                       at_f25519_t const *  t ) {
  at_f25519_set( r->X, x );
  at_f25519_set( r->Y, y );
  at_f25519_set( r->Z, z );
  at_f25519_set( r->T, t );
  return r;
}

/* at_ed25519_point_to extracts (x, y, z, t) from a point. */
AT_25519_INLINE void
at_ed25519_point_to( at_f25519_t *              x,
                     at_f25519_t *              y,
                     at_f25519_t *              z,
                     at_f25519_t *              t,
                     at_ed25519_point_t const * a ) {
  at_f25519_set( x, a->X );
  at_f25519_set( y, a->Y );
  at_f25519_set( z, a->Z );
  at_f25519_set( t, a->T );
}

/* at_ed25519_point_neg computes r = -a. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_neg( at_ed25519_point_t *       r,
                      at_ed25519_point_t const * a ) {
  at_f25519_neg( r->X, a->X );
  at_f25519_set( r->Y, a->Y );
  at_f25519_set( r->Z, a->Z );
  at_f25519_neg( r->T, a->T );

  /* Reduce after negation. at_f25519_neg uses bias constants that assume
     reduced input. If input limbs are near the bias values, the output
     can have limbs exceeding the expected bit widths, causing overflow
     in subsequent SIMD operations. */
  at_f25519_carry( r->X );
  at_f25519_carry( r->T );
  return r;
}

/* at_ed25519_point_eq returns 1 if a == b, 0 otherwise. */
AT_25519_INLINE int
at_ed25519_point_eq( at_ed25519_point_t const * a,
                     at_ed25519_point_t const * b ) {
  at_f25519_t x1[1], x2[1], y1[1], y2[1];
  at_f25519_mul( x1, b->X, a->Z );
  at_f25519_mul( x2, a->X, b->Z );
  at_f25519_mul( y1, b->Y, a->Z );
  at_f25519_mul( y2, a->Y, b->Z );
  return at_f25519_eq( x1, x2 ) & at_f25519_eq( y1, y2 );
}

/* at_ed25519_point_eq_z1 returns 1 if a == b, 0 otherwise.
   b is a point with Z==1, e.g. a decompressed point. */
AT_25519_INLINE int
at_ed25519_point_eq_z1( at_ed25519_point_t const * a,
                        at_ed25519_point_t const * b ) { /* b.Z == 1, e.g. a decompressed point */
  at_f25519_t x1[1], y1[1];
  at_f25519_mul( x1, b->X, a->Z );
  at_f25519_mul( y1, b->Y, a->Z );
  return at_f25519_eq( x1, a->X ) & at_f25519_eq( y1, a->Y );
}

/* at_curve25519_into_precomputed transforms a point into
   precomputed table format, e.g. replaces T -> kT to save
   1mul in the dbl-and-add loop. */
AT_25519_INLINE void
at_curve25519_into_precomputed( at_ed25519_point_t * r ) {
#if CURVE25519_PRECOMP_XY
  at_f25519_t add[1], sub[1];
  at_f25519_add_nr( add, r->Y, r->X );
  at_f25519_sub_nr( sub, r->Y, r->X );
  at_f25519_set( r->X, sub );
  at_f25519_set( r->Y, add );
#endif
  at_f25519_mul( r->T, r->T, at_f25519_k );
}

/* ========================================================================
   Point Doubling (Partial and Final)
   ======================================================================== */

/* at_ed25519_partial_dbl computes intermediate values for point doubling
   using dbl-2008-hwcd formula for twisted Edwards curve with a=-1 (Ed25519).
   Formula: A=X^2, B=Y^2, C=2*Z^2, D=-A (since a=-1)
            E=(X+Y)^2-A-B=2XY, G=D+B=B-A, F=G-C, H=D-B=-(A+B)
   Output: X3=E*F, Y3=G*H, T3=E*H, Z3=G*F
   This allows chaining multiple doublings efficiently.
   Output is in "lazy" form that needs at_ed25519_point_add_final_mul. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_partial_dbl( at_ed25519_point_t *       r,
                        at_ed25519_point_t const * a ) {
  at_f25519_t a_sq[1], b_sq[1], two_c[1], sum[1];

  /* A = X^2, B = Y^2 */
  at_f25519_sqr2( a_sq, a->X, b_sq, a->Y );

  /* E = (X+Y)^2 - A - B = 2XY (stored in r->T) */
  at_f25519_add_nr( r->T, a->X, a->Y );
  at_f25519_sqr( r->T, r->T );
  at_f25519_add_nr( sum, a_sq, b_sq );  /* A + B */
  at_f25519_sub_nr( r->T, r->T, sum );  /* E = (X+Y)^2 - (A+B) */

  /* G = B - A (stored in r->Z) for Ed25519 where a=-1 */
  at_f25519_sub_nr( r->Z, b_sq, a_sq );

  /* F = G - 2*Z^2 (stored in r->X) */
  at_f25519_sqr( two_c, a->Z );
  at_f25519_add_nr( two_c, two_c, two_c );
  at_f25519_sub_nr( r->X, r->Z, two_c );

  /* H = -(A+B) (stored in r->Y)
     IMPORTANT: sum is unreduced from add_nr, so we must reduce it first.
     Otherwise, limbs can exceed the neg bias constants, causing underflow. */
  at_f25519_carry( sum );
  at_f25519_neg( r->Y, sum );

  return r;
}

/* at_ed25519_point_add_final_mul computes the final multiplications for point add.
   Input is partial result from partial_dbl or partial_add.
   r = (E*F : G*H : F*G : E*H) */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_add_final_mul( at_ed25519_point_t * restrict r,
                                at_ed25519_point_t const * restrict partial ) {
  at_f25519_t E[1], F[1], G[1], H[1];

  /* Reduce partial results before mul4.
     The partial values come from _nr operations and can have limbs up to ~28 bits.
     When mul4 computes 19*b[j], the result can exceed 32 bits, causing silent
     truncation in the SIMD wwl_mul_ll (32x32->64) operation. Carry propagation
     ensures limbs are in the proper 25/26-bit ranges. */
  at_f25519_set( E, partial->T );
  at_f25519_set( F, partial->X );
  at_f25519_set( G, partial->Z );
  at_f25519_set( H, partial->Y );
  at_f25519_carry( E );
  at_f25519_carry( F );
  at_f25519_carry( G );
  at_f25519_carry( H );

  at_f25519_mul4( r->X, E, F,
                  r->Y, G, H,
                  r->Z, F, G,
                  r->T, E, H );

  /* Canonicalize to ensure field elements are in [0, p) */
  at_f25519_canonicalize( r->X );
  at_f25519_canonicalize( r->Y );
  at_f25519_canonicalize( r->Z );
  at_f25519_canonicalize( r->T );
  return r;
}

/* at_ed25519_point_add_final_mul_projective is similar but outputs projective form.
   Used for intermediate doublings. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_add_final_mul_projective( at_ed25519_point_t * restrict r,
                                           at_ed25519_point_t const * restrict partial ) {
  return at_ed25519_point_add_final_mul( r, partial );
}

/* at_ed25519_point_dbln computes r = 2^n * a, and returns r. */
AT_25519_INLINE at_ed25519_point_t *
at_ed25519_point_dbln( at_ed25519_point_t *       r,
                       at_ed25519_point_t const * a,
                       int const                  n ) {
  at_ed25519_point_t t[1];
  at_ed25519_partial_dbl( t, a );
  for( int i = 1; i < n; i++ ) {
    at_ed25519_point_add_final_mul_projective( r, t );
    at_ed25519_partial_dbl( t, r );
  }
  return at_ed25519_point_add_final_mul( r, t );
}

AT_PROTOTYPES_END

#endif /* AT_HAS_AVX512_GENERAL */

#endif /* HEADER_at_src_crypto_ed25519_avx512_general_at_curve25519_h */
